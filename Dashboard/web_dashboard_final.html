<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Battery Monitor</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        #monitor { margin-bottom: 20px; }
        #voltageCanvas, #temperatureCanvas {
            margin-top: 5px;
            border: 1px solid #ccc;
            cursor: pointer;
        }
        #log-view {
            background: #ccc;
            color: rgb(0, 0, 255);
            padding: 10px;
            height: 300px;
            overflow-y: scroll;
            white-space: pre-wrap;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="splash-screen"
         style="position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: white; display: flex; justify-content: center; align-items: center; z-index: 9999;">
        <img src="/static/black_logo_white_background.jpg"
             alt="Zurich UAS Racing Logo" style="max-width: 1000px;">
    </div>

    <div style="display: flex; align-items: center; gap: 20px;">
        <img src="/static/black_logo_white_background.jpg"
             alt="Zurich UAS Racing Logo" height="50">
        <h2>Battery Monitor</h2>
        <div id="status-banner"
             style="color: red; font-weight: bold; margin-bottom: 10px;"></div>
    </div>

    <div style="display: flex; gap: 40px; align-items: flex-start;">
        <div style="display: flex; flex-direction: column; gap: 20px;">
            <div style="display: flex; flex-direction: row; gap: 20px;">
                <div>
                    <h3>Voltage Map</h3>
                    <canvas id="voltageCanvas" width="600" height="300"></canvas>
                </div>
                <div>
                    <h3>Temperature Map</h3>
                    <canvas id="temperatureCanvas" width="600" height="300"></canvas>
                </div>
                <div style="min-width: 300px;">
                    <h3>Battery Summary</h3>
                    <div id="monitor">Loading battery data...</div>
                </div>
            </div>
            <div>
                <h3>Serial Console</h3>
                <div id="log-view">Waiting for logs...</div>
            </div>
        </div>
    </div>

    <script>
    // Change this to match your backend's CLIENTS constant:
    const CLIENTS = 8;

    // These will hold any user‐entered values for cells that were "n/a":
    const manualVoltage = {};
    const manualTemp    = {};

    function updateMonitor() {
        fetch("/battery")
            .then(resp => resp.text())
            .then(html => {
                const banner = document.getElementById("status-banner");
                document.getElementById("monitor").innerHTML = html;

                if (html.includes("Parse error")) {
                    banner.textContent = "❌ Warning: Invalid or false frame received!";
                } else if (html.includes("Waiting for data")) {
                    banner.textContent = "⏳ Waiting for data from board...";
                } else {
                    banner.textContent = "";
                }
            });
    }

    // Draw voltage heatmap:
    // - Normal cells (idx < voltageArray.length) are color‐mapped.
    // - Cells with manualVoltage overrides behave like normal cells.
    // - Cells idx >= voltageArray.length and no override are gray with "n/a".
    function drawVoltageHeatmap(voltageArray, balanceArray) {
        const canvas = document.getElementById("voltageCanvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const cols = 18;
        const totalCells = CLIENTS * cols; 
        const rows = CLIENTS;

        const cellW = canvas.width / cols;
        const cellH = canvas.height / rows;

        // Build an array of "effective" voltages, combining real data + manual overrides:
        const effective = new Array(rows * cols).fill(null);
        // 1) Fill from real data:
        for (let i = 0; i < voltageArray.length && i < rows * cols; i++) {
            effective[i] = voltageArray[i];
        }
        // 2) Fill from manual overrides, if any:
        for (const idxStr in manualVoltage) {
            const idx = Number(idxStr);
            if (!isNaN(idx) && idx >= 0 && idx < rows * cols) {
                effective[idx] = manualVoltage[idx];
            }
        }

        // Compute min/max for coloring only among the cells that have numeric values:
        const numericVals = effective.filter(v => v !== null);
        let minV = numericVals.length ? Math.min(...numericVals) : 0;
        let maxV = numericVals.length ? Math.max(...numericVals) : 1;
        if (maxV === minV) { maxV += 1e-6; } // avoid zero‐range

        // Draw every cell in an CLIENTS×18 grid:
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const idx = r * cols + c;
                const val = effective[idx];

                if (val === null) {
                    // “n/a” cell
                    ctx.fillStyle = "#777";   // gray
                    ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
                    ctx.fillStyle = "white";
                    ctx.font = "12px monospace";
                    ctx.fillText("n/a", c * cellW + 4, r * cellH + 14);
                } else {
                    // Numeric cell → color‐map from blue→red
                    const norm = (val - minV) / (maxV - minV);
                    const blue = Math.floor(255 * (1 - norm));
                    const red  = Math.floor(255 * norm);
                    ctx.fillStyle = `rgb(${red}, 0, ${blue})`;
                    ctx.fillRect(c * cellW, r * cellH, cellW, cellH);

                    // Draw the numeric text (white, small)
                    ctx.fillStyle = "white";
                    ctx.font = "12px monospace";
                    ctx.fillText(val.toFixed(3), c * cellW + 4, r * cellH + 14);
                }
            }
        }

        // Overlay balance‐bits (semi‐transparent blue) on real cells and manual cells alike:
        if (Array.isArray(balanceArray) && balanceArray.length === rows) {
            for (let r = 0; r < rows; r++) {
                const bmp = balanceArray[r];
                for (let c = 0; c < cols; c++) {
                    if (bmp & (1 << c)) {
                        ctx.fillStyle = "rgba(0, 0, 255, 0.3)";
                        ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
                    }
                }
            }
        }
    }

    // Draw temperature heatmap similarly (CLIENTS × 8):
    function drawTemperatureHeatmap(tempArray) {
        const canvas = document.getElementById("temperatureCanvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const cols = 8;
        const totalCells = CLIENTS * cols;
        const rows = CLIENTS;
        const cellW = canvas.width / cols;
        const cellH = canvas.height / rows;

        // Combine real + manual:
        const effective = new Array(rows * cols).fill(null);
        for (let i = 0; i < tempArray.length && i < rows * cols; i++) {
            effective[i] = tempArray[i];
        }
        for (const idxStr in manualTemp) {
            const idx = Number(idxStr);
            if (!isNaN(idx) && idx >= 0 && idx < rows * cols) {
                effective[idx] = manualTemp[idx];
            }
        }

        const numericVals = effective.filter(v => v !== null);
        let minT = numericVals.length ? Math.min(...numericVals) : 0;
        let maxT = numericVals.length ? Math.max(...numericVals) : 1;
        if (maxT === minT) { maxT += 1e-6; }

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const idx = r * cols + c;
                const t = effective[idx];

                if (t === null) {
                    // “n/a” cell
                    ctx.fillStyle = "#777";
                    ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
                    ctx.fillStyle = "white";
                    ctx.font = "12px monospace";
                    ctx.fillText("n/a", c * cellW + 4, r * cellH + 14);
                } else {
                    // Numeric cell → color‐map
                    const norm = (t - minT) / (maxT - minT);
                    const blue = Math.floor(255 * (1 - norm));
                    const red  = Math.floor(255 * norm);
                    ctx.fillStyle = `rgb(${red}, 0, ${blue})`;
                    ctx.fillRect(c * cellW, r * cellH, cellW, cellH);

                    ctx.fillStyle = "white";
                    ctx.font = "12px monospace";
                    ctx.fillText(t.toFixed(1) + "°C", c * cellW + 4, r * cellH + 14);
                }
            }
        }
    }

    function updateGraphics() {
        fetch("/battery-json")
            .then(r => r.json())
            .then(data => {
                if (Array.isArray(data.voltage_grid) && Array.isArray(data.balance_grid)) {
                    drawVoltageHeatmap(data.voltage_grid, data.balance_grid);
                }
                if (Array.isArray(data.temperature_grid)) {
                    drawTemperatureHeatmap(data.temperature_grid);
                }
            })
            .catch(err => {
                console.error("Error fetching battery-json:", err);
            });
    }

    function updateLogs() {
        fetch("/logs")
            .then(resp => resp.json())
            .then(lines => {
                const logDiv = document.getElementById("log-view");
                logDiv.textContent = lines.join("\n");
                logDiv.scrollTop = logDiv.scrollHeight;
            });
    }

    function updateAll() {
        updateMonitor();
        updateGraphics();
        updateLogs();
    }

    // Set up click handlers to prompt user for manual entry if "n/a" is clicked:
    window.addEventListener("DOMContentLoaded", () => {
        const vCanvas = document.getElementById("voltageCanvas");
        const tCanvas = document.getElementById("temperatureCanvas");

        vCanvas.addEventListener("click", (e) => {
            const rect = vCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const cols = 18, rows = CLIENTS;
            const cellW = vCanvas.width / cols;
            const cellH = vCanvas.height / rows;
            const c = Math.floor(x / cellW);
            const r = Math.floor(y / cellH);
            const idx = r * cols + c;

            // We need to fetch the latest data length to compare:
            fetch("/battery-json")
                .then(r => r.json())
                .then(data => {
                    const dataLen = data.voltage_grid.length;
                    if (idx >= dataLen) {
                        const input = prompt(`Enter a numeric voltage for cell index ${idx}:`);
                        if (input !== null) {
                            const num = parseFloat(input);
                            if (!isNaN(num)) {
                                manualVoltage[idx] = num;
                                drawVoltageHeatmap(data.voltage_grid, data.balance_grid);
                            } else {
                                alert("Invalid number—please try again.");
                            }
                        }
                    }
                })
                .catch(console.error);
        });

        tCanvas.addEventListener("click", (e) => {
            const rect = tCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const cols = 8, rows = CLIENTS;
            const cellW = tCanvas.width / cols;
            const cellH = tCanvas.height / rows;
            const c = Math.floor(x / cellW);
            const r = Math.floor(y / cellH);
            const idx = r * cols + c;

            fetch("/battery-json")
                .then(r => r.json())
                .then(data => {
                    const dataLen = data.temperature_grid.length;
                    if (idx >= dataLen) {
                        const input = prompt(`Enter a numeric temperature (°C) for cell index ${idx}:`);
                        if (input !== null) {
                            const num = parseFloat(input);
                            if (!isNaN(num)) {
                                manualTemp[idx] = num;
                                drawTemperatureHeatmap(data.temperature_grid);
                            } else {
                                alert("Invalid number—please try again.");
                            }
                        }
                    }
                })
                .catch(console.error);
        });

        // Start the polling loop:
        setInterval(updateAll, 1000);
        updateAll();

        // Fade out splash screen after load:
        const splash = document.getElementById("splash-screen");
        if (splash) {
            splash.style.transition = "opacity 5s ease";
            splash.style.opacity = 0;
            setTimeout(() => splash.remove(), 5000);
        }
    });
    </script>
</body>
</html>
