<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Battery Monitor</title>
    <style>
        body { font-family: monospace; padding: 20px; }
        #monitor { margin-bottom: 20px; }
        #voltageCanvas, #temperatureCanvas {
            margin-top: 5px;
            border: 1px solid #ccc;
            cursor: pointer;
        }
        #log-view {
            background: #ccc;
            color: rgb(0, 0, 255);
            padding: 10px;
            height: 300px;
            overflow-y: scroll;
            white-space: pre-wrap;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div id="splash-screen"
         style="position: fixed; top: 0; left: 0; right: 0; bottom: 0;
                background: white; display: flex; justify-content: center; align-items: center; z-index: 9999;">
        <img src="/static/black_logo_white_background.jpg"
             alt="Zurich UAS Racing Logo" style="max-width: 1000px;">
    </div>

    <div style="display: flex; align-items: center; gap: 20px;">
        <img src="/static/black_logo_white_background.jpg"
             alt="Zurich UAS Racing Logo" height="50">
        <h2>Battery Monitor</h2>
        <div id="status-banner"
             style="color: red; font-weight: bold; margin-bottom: 10px;"></div>
    </div>

    <div style="display: flex; gap: 40px; align-items: flex-start;">
        <div style="display: flex; flex-direction: column; gap: 20px;">
            <div style="display: flex; flex-direction: row; gap: 20px;">
                <div>
                    <h3>Voltage Map</h3>
                    <canvas id="voltageCanvas" width="600" height="300"></canvas>
                </div>
                <div>
                    <h3>Temperature Map</h3>
                    <canvas id="temperatureCanvas" width="600" height="300"></canvas>
                </div>
                <div style="min-width: 300px;">
                    <h3>Battery Summary</h3>
                    <div id="monitor">Loading battery data...</div>
                </div>
            </div>
            <div>
                <h3>Serial Console</h3>
                <div id="log-view">Waiting for logs...</div>
            </div>
        </div>
    </div>

    <script>
    // === CONFIGURATION ===
    // Change CLIENTS to match your backend constant:
    const CLIENTS = 8;

    // Any indices you list here will be forced to "n/a" on the voltage map:
    // e.g. if sensor at index 42 fails, add 42 to this array.
    const disabledVoltage = [
        // Example: 142, 143
    ];

    // Any indices you list here will be forced to "n/a" on the temperature map:
    const disabledTemp = [
        // Example: 10, 27
    ];

    // These hold user‐entered values for cells originally flagged "n/a":
    const manualVoltage = {};
    const manualTemp    = {};

    function updateMonitor() {
        fetch("/battery")
            .then(resp => resp.text())
            .then(html => {
                const banner = document.getElementById("status-banner");
                document.getElementById("monitor").innerHTML = html;

                if (html.includes("Parse error")) {
                    banner.textContent = "❌ Warning: Invalid or false frame received!";
                } else if (html.includes("Waiting for data")) {
                    banner.textContent = "⏳ Waiting for data from board...";
                } else {
                    banner.textContent = "";
                }
            });
    }

    // Helper to check if idx is disabled for voltage:
    function isVoltageDisabled(idx) {
        return disabledVoltage.includes(idx);
    }

    // Helper to check if idx is disabled for temperature:
    function isTempDisabled(idx) {
        return disabledTemp.includes(idx);
    }

    // === Drawing Voltage Heatmap ===
    function drawVoltageHeatmap(voltageArray, balanceArray) {
        const canvas = document.getElementById("voltageCanvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const cols = 18;
        const rows = CLIENTS;
        const totalCells = rows * cols;
        const cellW = canvas.width / cols;
        const cellH = canvas.height / rows;

        // Build "effective" array: start with nulls
        const effective = new Array(totalCells).fill(null);

        // 1) Real data:
        for (let i = 0; i < voltageArray.length && i < totalCells; i++) {
            // If this index is marked disabled, skip (leave null)
            if (!isVoltageDisabled(i)) {
                effective[i] = voltageArray[i];
            }
        }

        // 2) Manual overrides (always override, even if disabled list is empty):
        for (const idxStr in manualVoltage) {
            const idx = Number(idxStr);
            if (!isNaN(idx) && idx >= 0 && idx < totalCells) {
                effective[idx] = manualVoltage[idx];
            }
        }

        // 3) Any index explicitly disabled but also manually overridden:
        // If manually overridden, that value stays. Otherwise, remains null.

        // Compute min/max among numeric values for color scaling:
        const numericVals = effective.filter(v => v !== null);
        let minV = numericVals.length ? Math.min(...numericVals) : 0;
        let maxV = numericVals.length ? Math.max(...numericVals) : 1;
        if (maxV === minV) { maxV += 1e-6; }

        // Draw grid:
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const idx = r * cols + c;
                const val = effective[idx];

                if (val === null) {
                    // "n/a" or disabled cell
                    ctx.fillStyle = "#777";   // gray background
                    ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
                    ctx.fillStyle = "white";
                    ctx.font = "12px monospace";
                    ctx.fillText("n/a", c * cellW + 4, r * cellH + 14);
                } else {
                    // Valid numeric → color-map
                    const norm = (val - minV) / (maxV - minV);
                    const blue = Math.floor(255 * (1 - norm));
                    const red  = Math.floor(255 * norm);
                    ctx.fillStyle = `rgb(${red}, 0, ${blue})`;
                    ctx.fillRect(c * cellW, r * cellH, cellW, cellH);

                    ctx.fillStyle = "white";
                    ctx.font = "12px monospace";
                    ctx.fillText(val.toFixed(3), c * cellW + 4, r * cellH + 14);
                }
            }
        }

        // Overlay balance bits (semi-transparent blue) on all non-null cells:
        if (Array.isArray(balanceArray) && balanceArray.length === rows) {
            for (let r = 0; r < rows; r++) {
                const bmp = balanceArray[r];
                for (let c = 0; c < cols; c++) {
                    const idx = r * cols + c;
                    // Only overlay if cell is not null
                    if (effective[idx] !== null && (bmp & (1 << c))) {
                        ctx.fillStyle = "rgba(0, 0, 255, 0.3)";
                        ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
                    }
                }
            }
        }
    }

    // === Drawing Temperature Heatmap ===
    function drawTemperatureHeatmap(tempArray) {
        const canvas = document.getElementById("temperatureCanvas");
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const cols = 8;
        const rows = CLIENTS;
        const totalCells = rows * cols;
        const cellW = canvas.width / cols;
        const cellH = canvas.height / rows;

        // Build "effective" array: start with nulls
        const effective = new Array(totalCells).fill(null);

        // 1) Real data:
        for (let i = 0; i < tempArray.length && i < totalCells; i++) {
            if (!isTempDisabled(i)) {
                effective[i] = tempArray[i];
            }
        }

        // 2) Manual overrides:
        for (const idxStr in manualTemp) {
            const idx = Number(idxStr);
            if (!isNaN(idx) && idx >= 0 && idx < totalCells) {
                effective[idx] = manualTemp[idx];
            }
        }

        // Compute min/max for color scaling:
        const numericVals = effective.filter(v => v !== null);
        let minT = numericVals.length ? Math.min(...numericVals) : 0;
        let maxT = numericVals.length ? Math.max(...numericVals) : 1;
        if (maxT === minT) { maxT += 1e-6; }

        // Draw grid:
        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                const idx = r * cols + c;
                const t = effective[idx];

                if (t === null) {
                    // "n/a" or disabled cell
                    ctx.fillStyle = "#777";
                    ctx.fillRect(c * cellW, r * cellH, cellW, cellH);
                    ctx.fillStyle = "white";
                    ctx.font = "12px monospace";
                    ctx.fillText("n/a", c * cellW + 4, r * cellH + 14);
                } else {
                    // Valid numeric → color-map
                    const norm = (t - minT) / (maxT - minT);
                    const blue = Math.floor(255 * (1 - norm));
                    const red  = Math.floor(255 * norm);
                    ctx.fillStyle = `rgb(${red}, 0, ${blue})`;
                    ctx.fillRect(c * cellW, r * cellH, cellW, cellH);

                    ctx.fillStyle = "white";
                    ctx.font = "12px monospace";
                    ctx.fillText(t.toFixed(1) + "°C", c * cellW + 4, r * cellH + 14);
                }
            }
        }
    }

    function updateGraphics() {
        fetch("/battery-json")
            .then(r => r.json())
            .then(data => {
                if (Array.isArray(data.voltage_grid) && Array.isArray(data.balance_grid)) {
                    drawVoltageHeatmap(data.voltage_grid, data.balance_grid);
                }
                if (Array.isArray(data.temperature_grid)) {
                    drawTemperatureHeatmap(data.temperature_grid);
                }
            })
            .catch(err => {
                console.error("Error fetching battery-json:", err);
            });
    }

    function updateLogs() {
        fetch("/logs")
            .then(resp => resp.json())
            .then(lines => {
                const logDiv = document.getElementById("log-view");
                logDiv.textContent = lines.join("\n");
                logDiv.scrollTop = logDiv.scrollHeight;
            });
    }

    function updateAll() {
        updateMonitor();
        updateGraphics();
        updateLogs();
    }

    // === CLICK HANDLERS ===
    // Clicking on a cell that is currently "n/a" (beyond real data length or in disabled list)
    // allows the user to enter a manual override. This works for both voltage and temperature.

    window.addEventListener("DOMContentLoaded", () => {
        const vCanvas = document.getElementById("voltageCanvas");
        const tCanvas = document.getElementById("temperatureCanvas");

        vCanvas.addEventListener("click", (e) => {
            const rect = vCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const cols = 18, rows = CLIENTS;
            const cellW = vCanvas.width / cols;
            const cellH = vCanvas.height / rows;
            const c = Math.floor(x / cellW);
            const r = Math.floor(y / cellH);
            const idx = r * cols + c;

            fetch("/battery-json")
                .then(r => r.json())
                .then(data => {
                    const dataLen = data.voltage_grid.length;
                    // If idx is beyond real data or explicitly disabled, prompt for manual entry:
                    if (idx >= dataLen || isVoltageDisabled(idx)) {
                        const input = prompt(`Enter a numeric voltage for cell index ${idx}:`);
                        if (input !== null) {
                            const num = parseFloat(input);
                            if (!isNaN(num)) {
                                manualVoltage[idx] = num;
                                drawVoltageHeatmap(data.voltage_grid, data.balance_grid);
                            } else {
                                alert("Invalid number—please try again.");
                            }
                        }
                    }
                })
                .catch(console.error);
        });

        tCanvas.addEventListener("click", (e) => {
            const rect = tCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            const cols = 8, rows = CLIENTS;
            const cellW = tCanvas.width / cols;
            const cellH = tCanvas.height / rows;
            const c = Math.floor(x / cellW);
            const r = Math.floor(y / cellH);
            const idx = r * cols + c;

            fetch("/battery-json")
                .then(r => r.json())
                .then(data => {
                    const dataLen = data.temperature_grid.length;
                    if (idx >= dataLen || isTempDisabled(idx)) {
                        const input = prompt(`Enter a numeric temperature (°C) for cell index ${idx}:`);
                        if (input !== null) {
                            const num = parseFloat(input);
                            if (!isNaN(num)) {
                                manualTemp[idx] = num;
                                drawTemperatureHeatmap(data.temperature_grid);
                            } else {
                                alert("Invalid number—please try again.");
                            }
                        }
                    }
                })
                .catch(console.error);
        });

        // Start polling every 0.1s (100ms)
        setInterval(updateAll, 100);
        updateAll();

        // Fade out splash
        const splash = document.getElementById("splash-screen");
        if (splash) {
            splash.style.transition = "opacity 5s ease";
            splash.style.opacity = 0;
            setTimeout(() => splash.remove(), 5000);
        }
    });
    </script>
</body>
</html>
